<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>AI Study Chat</title>

<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: "Segoe UI", Tahoma, sans-serif;
  background: #343541;
  color: #ececf1;
  height: 100vh;
}

#container {
  display: flex;
  height: 100vh;
}

/* ===== SIDEBAR ===== */
#sidebar {
  width: 260px;
  background: #202123;
  display: flex;
  flex-direction: column;
  border-right: 1px solid #2f2f38;
}

#new-chat {
  margin: 12px;
  padding: 12px;
  border-radius: 8px;
  border: 1px solid #4d4d4f;
  background: transparent;
  color: #fff;
  cursor: pointer;
}
#new-chat:hover { background: #2a2b32; }

#conversations {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.conv {
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  color: #d9d9e3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.conv:hover { background: #2a2b32; }
.conv.active { background: #343541; }

/* ===== CHAT ===== */
#chat-area {
  flex: 1;
  display: flex;
  flex-direction: column;
}

#chat {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* üîß FIX: bong b√≥ng √¥m ch·ªØ */
.msg {
  display: inline-block;
  max-width: 70%;
  padding: 14px 20px;
  border-radius: 18px;
  white-space: pre-wrap;
  word-wrap: break-word;
  line-height: 1.45;
}

.user {
  background: #10a37f;
  margin-left: auto;
  color: #fff;
}

.ai {
  background: #444654;
  margin-right: auto;
  color: #ececf1;
}

/* ===== INPUT ===== */
#input-area {
  border-top: 1px solid #2f2f38;
  padding: 16px;
}

#input-box {
  max-width: 800px;
  margin: auto;
  display: flex;
  background: #40414f;
  border-radius: 8px;
}

#input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  padding: 14px;
  color: #fff;
  font-size: 15px;
}

button {
  background: transparent;
  border: none;
  color: #10a37f;
  font-size: 20px;
  padding: 0 14px;
  cursor: pointer;
}
button:hover { opacity: 0.8; }

/* ===== DOTS ===== */
.dots span {
  animation: blink 1.4s infinite both;
}
.dots span:nth-child(2) { animation-delay: .2s; }
.dots span:nth-child(3) { animation-delay: .4s; }

@keyframes blink {
  0% { opacity: .2; }
  20% { opacity: 1; }
  100% { opacity: .2; }
}
</style>
</head>

<body>
<div id="container">

  <div id="sidebar">
    <button id="new-chat" onclick="newChat()">+ New chat</button>
    <div id="conversations"></div>
  </div>

  <div id="chat-area">
    <div id="chat"></div>

    <div id="input-area">
      <div id="input-box">
        <input id="input" placeholder="Send a message..." />
        <button onclick="send()">‚û§</button>
        <button onclick="startVoice()">üé§</button>
        <button onclick="toggleVoice()" id="voiceToggle">üîä</button>
      </div>
    </div>
  </div>

</div>

<script>
/* ===== STATE ===== */
let chats = JSON.parse(localStorage.getItem("chats") || "{}")
let currentChat = localStorage.getItem("currentChat") || null
let isGenerating = false
let voiceEnabled = JSON.parse(localStorage.getItem("voiceEnabled") ?? "true")

function save() {
  localStorage.setItem("chats", JSON.stringify(chats))
  localStorage.setItem("currentChat", currentChat)
  localStorage.setItem("voiceEnabled", voiceEnabled)
}

/* ===== SIDEBAR ===== */
function renderSidebar() {
  const box = document.getElementById("conversations")
  box.innerHTML = ""
  Object.keys(chats).forEach(id => {
    const div = document.createElement("div")
    div.className = "conv" + (id === currentChat ? " active" : "")
    div.textContent = chats[id].title || "New chat"
    div.onclick = () => loadChat(id)
    box.appendChild(div)
  })
}

/* ===== CHAT ===== */
function renderChat() {
  const chatBox = document.getElementById("chat")
  chatBox.innerHTML = ""
  if (!currentChat) return

  chats[currentChat].messages.forEach(m => {
    const div = document.createElement("div")
    div.className = "msg " + m.role
    if (m.streaming && !m.text) {
      div.innerHTML = '<span class="dots"><span>.</span><span>.</span><span>.</span></span>'
    } else {
      div.textContent = m.text
    }
    chatBox.appendChild(div)
  })

  chatBox.scrollTop = chatBox.scrollHeight
}

function newChat() {
  currentChat = crypto.randomUUID()
  chats[currentChat] = { title: "New chat", messages: [] }
  save(); renderSidebar(); renderChat()
}

function loadChat(id) {
  currentChat = id
  save(); renderSidebar(); renderChat()
}

/* ===== STREAMING ===== */
function streamText(aiMsg, fullText) {
  const words = fullText.split(/(\s+)/)
  let i = 0

  const timer = setInterval(() => {
    aiMsg.streaming = false
    aiMsg.text += words[i] || ""
    renderChat()
    save()
    i++

    if (i >= words.length) {
      clearInterval(timer)
      isGenerating = false
      if (voiceEnabled) speak(fullText)
    }
  }, 45)
}

/* ===== SEND ===== */
async function send() {
  if (isGenerating || !currentChat) return

  const input = document.getElementById("input")
  const text = input.value.trim()
  if (!text) return

  isGenerating = true
  input.value = ""

  const chat = chats[currentChat]
  if (chat.messages.length === 0) chat.title = text.slice(0, 30)

  chat.messages.push({ role: "user", text })
  const aiMsg = { role: "ai", text: "", streaming: true }
  chat.messages.push(aiMsg)

  save(); renderSidebar(); renderChat()

  try {
    const res = await fetch("/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text, session_id: currentChat })
    })
    const data = await res.json()
    streamText(aiMsg, data.reply || "")
  } catch {
    aiMsg.text = "Error"
    aiMsg.streaming = false
    isGenerating = false
    save(); renderChat()
  }
}

/* ===== VOICE INPUT (AUTO DETECT) ===== */
function startVoice() {
  if (isGenerating) return
  if (!('webkitSpeechRecognition' in window)) {
    alert("Voice input not supported")
    return
  }
  const r = new webkitSpeechRecognition()
  r.lang = navigator.language || "vi-VN"
  r.onresult = e => {
    document.getElementById("input").value = e.results[0][0].transcript
    send()
  }
  r.start()
}

/* ===== VOICE OUTPUT (AUTO VI / EN) ===== */

/* ===== VOICE OUTPUT (AUTO VI / EN) ===== */

/* ===== VOICE OUTPUT (AUTO VI / EN) ===== */

// Ki·ªÉm tra c√≥ ph·∫£i ti·∫øng Vi·ªát hay kh√¥ng
function isVietnamese(text) {
  return /[√†√°·∫°·∫£√£√¢ƒÉƒë√™√¥∆°∆∞√®√©·∫π·∫ª·∫Ω√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√π√∫·ª•·ªß≈©·ª≥√Ω·ªµ·ª∑·ªπ]/i.test(text)
}

// L·∫•y voice t·ªët nh·∫•t theo ng√¥n ng·ªØ
function getBestVoice(lang) {
  const voices = speechSynthesis.getVoices()
  if (!voices.length) return null

  if (lang === "vi") {
    // ∆∞u ti√™n Google Vietnamese
    return voices.find(v => v.lang === "vi-VN" && v.name.toLowerCase().includes("google"))
           || voices.find(v => v.lang.startsWith("vi"))
  }

  // English
  return voices.find(v => v.lang.startsWith("en") && v.name.toLowerCase().includes("google"))
         || voices.find(v => v.lang.startsWith("en"))
}

// H√†m ƒë·ªçc text
function speak(text) {
  if (!("speechSynthesis" in window)) return
  if (!voiceEnabled) return

  const lang = isVietnamese(text) ? "vi" : "en"
  let voice = getBestVoice(lang)

  // N·∫øu voices ch∆∞a load, ch·ªù load xong r·ªìi g·ªçi l·∫°i
  if (!voice) {
    speechSynthesis.onvoiceschanged = () => speak(text)
    return
  }

  const utter = new SpeechSynthesisUtterance(text)
  utter.voice = voice
  utter.lang = voice.lang
  // Rate h∆°i ch·∫≠m ƒë·ªÉ ti·∫øng Vi·ªát r√µ h∆°n, ti·∫øng Anh b√¨nh th∆∞·ªùng
  utter.rate = lang === "vi" ? 0.95 : 1
  utter.pitch = 1

  speechSynthesis.speak(utter)
}

/* ===== TOGGLE VOICE ===== */
function toggleVoice() {
  voiceEnabled = !voiceEnabled
  document.getElementById("voiceToggle").textContent = voiceEnabled ? "üîä" : "üîá"
  save()
}

document.getElementById("voiceToggle").textContent = voiceEnabled ? "üîä" : "üîá"

/* ===== INIT ===== */
if (!currentChat) newChat()
renderSidebar(); renderChat()
</script>
</body>
</html>
